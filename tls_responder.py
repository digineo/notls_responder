#!/usr/bin/env python3
import sys
import os
import re
from email.message import Message
from email.parser import HeaderParser
from email.utils import parseaddr
from email.mime.text import MIMEText
from smtplib import SMTP, SMTPException
import re


class TLSresponder(object):
    """This Class checks if a given mail should be responded to"""
    # check noreply and system addresses

    noreplies = [
        "mailer-daemon",
        "noreply@",
        "no_reply@",
        "no-reply@",
        "do-not-reply@",
        "bounce@"
        "www@",
        "www-data@",
        "wwwrun@",
        "nobody@",
        "apache@",
        "root@",
        "nagios@",
        "httpd@",
        "hostmaster@",
        "postmaster@",
        "svn@",
            ]
    # check disallowed header fields
    headers = [
        'List-Id',
        'List-Unsubscribe',
        'List-Help',
        'List-Info',
        'RT-Originator',
        'X-List',
        'X-List-ID',
        'X-MDMailing-List',
        'X-Mailing-List',
        'X-Mailer-ListID',
        'X-MailingID',
        'X-Mailing-Id',
        'X-Autoresponder',
        'X-Autorespond',
        'X-Bugzilla-Product',
        'X-Bugzilla-Type',
        'X-Email-Type-Id', # Paypal
        'X-Google-Address-Confirmation', # Google
        'X-Roundup-Version',
        'X-Trac-Version',
        'X-Whups-Generated',
        'X-Cron-Env',
        ]
    def __init__(self, incommingmail):
        #read an parse mail header
        parser    = HeaderParser()
        self.orig_msg  = parser.parsestr(incommingmail)
        # read subject
        self.orig_subject = self.orig_msg.get('Subject')
        # read received, ignore all but last
        self.orig_received = self.orig_msg.get_all('Received')[0]
        # read sender
        self.returnsender = self.orig_msg['Return-Path'] or self.orig_msg['From']
        #replay adress
        self.sender_domain = self.get_domain(self.returnsender)
        self.orig_receiver = self.orig_msg.get("To")
        self.reply_address = "noreply@{}".format(self.get_domain(self.orig_receiver))
        
    def get_domain(self, addr):
        sender = parseaddr(addr)[1]
        sender = sender.split("@")[-1] 
        return sender

    def send_mail(self, dry=0):
        msg = self.create_message()
        received = []
        if dry==1:
           return  msg
        try:
            s = SMTP('localhost')
            s.ehlo()
            delivered = s.sendmail(self.reply_address, self.returnsender, msg.as_string())
            s.quit()  
        except ConnectionRefusedError:
            pass           
        return received
        received = mailer.deliver()
        return delivered
        

    def __abort(self, reason):
        reason = ("dropped, {}".format(reason))
        raise AbortReply(reason)


    # aborts if the given header matches the given value
    def __abort_if_header(self, name, disallowed):
        value = self.orig_msg.get(name)
        if value != None and value.lower() in disallowed: 
            self.__abort("disallowed header: {}".format(name));


    # aborts if the given header exists and does NOT match the given value
    def __abort_if_header_not(self, name, disallowed):
        value = self.orig_msg.get(name)
        if value != None and value.lower() not in disallowed:
            self.__abort("disallowed header: {}".format(name));

    def __abort_reason(self):
        reason = None
        if not self.orig_subject:
            self.__abort("subject missing");

    
        # check if locally delivered
        if "localhost" in self.orig_received:
            self.__abort("locally delivered")

        #check if tls encrypted
        if self.orig_received.find("TLS")>-1:
            self.__abort("sent with tls")

        #abort if sender and receiver have the same adress
        if self.returnsender == self.orig_receiver:
            self.__abort("same mail adress as sender")
        
        #check for disallowed Headers
        self.__abort_if_header_not('Auto-Submitted', 'no')
        self.__abort_if_header('X-Autogenerated', 'reply')
        self.__abort_if_header('X-Auto-Response-Suppress', 'all')
        self.__abort_if_header('X-Mailer', 'mediawiki mailer')
        self.__abort_if_header('X-Spam-Flag', 'yes')
        self.__abort_if_header('Precedence', ['list', 'bulk', 'junk'])
        self.__abort_if_header('Content-Description', 'delivery report')


        for name in TLSresponder.headers:
            if self.orig_msg.get(name) != None:
                self.__abort("header present: {}".format(name))



        sender_lower = self.returnsender.lower()
        for noreply in TLSresponder.noreplies:
            if noreply in sender_lower:
                self.__abort("disallowed address")



    #create mail
    def create_message(self):
        self.__abort_reason()
        mail_payload = [
        "Insecure transmission / Unsichere Zustellung", 
        """(deutsche Version unten) 

We've recently received an mail from your mail address through an insecure connection.
This mail could have been read or altered by a third party.
Please contact your mail server administrator and ask him to fix this security issue.
You may find further information at:

http://ssl-tools.net/mailservers/{0}


(english version above)

Wir haben soeben eine E-Mail ueber eine unsichere Verbindung von Ihrer Adresse erhalten.
Die E-Mail kann daher unbemerkt von Dritten mitgelesen und veraendert worden sein.
Bitte kontaktieren Sie den Administrator Ihres Mailservers und fordern Sie ihn auf, 
dieses Sicherheitsproblem zu beheben.
Die folgende Seite kann dabei hilfreich sein:

http://de.ssl-tools.net/mailservers/{0}

-- 
This mail has been generated by noTLS Responder
https://github.com/digineo/notls_responder
""".format(self.sender_domain)]
        msg = Message()
        msg["Subject"] = "{0}: {1}".format(mail_payload[0], self.orig_subject)
        msg["From"] = self.reply_address
        msg["To"] = self.returnsender
        msg["Precedence"] = "bulk"
        msg.set_payload(mail_payload[1])
        return msg


class AbortReply(Exception):
    """Thrown if EMail should not be responded to"""
    def __init__(self, reason):
        self.reason = reason
    def __str__(self):
        return "No Reply: {}".format(self.reason)

# Wenn Test-Framework geladen, nichts tun
if __name__ == "__main__":
    stdin = sys.stdin.read()
    dry = os.environ.get('DRY')
    response = TLSresponder(stdin)
    # Mail von STDIN parsen und bei Bedarf Mail per localhost versenden
    
    try:
        if not dry == '1':
            print(response.send_mail())
        else:
            # Wenn DRY=1, dann Mail von STDIN parsen und Ergebnis auf STDOUT ausgeben
            print(response.send_mail(1))
    except AbortReply as e:
        print(e.reason)
    sys.exit()