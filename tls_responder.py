#!/usr/bin/python3 
import sys
import os
import re
#import pdb
from email.message import Message
from email.parser import HeaderParser
from smtplib import SMTP

class MailSender(object):
    """docstring for MailSender"""
    def __init__(self, to, sender, body):
        self.reply_address = to
        self.returnsender = sender
        self.msg = body
    def deliver(self):
        #Send Mail
        received = []
        try:
            s = smtplib.SMTP('localhost')
            received = s.sendmail(self.reply_address, self.returnsender, self.msg)
        finally:
            s.quit()
        return received

class TestMailSender(MailSender):
    def __init__(self, to, sender, body):
        self.reply_address = to
        self.returnsender = sender
        self.msg = body
    def deliver(self):
        return [self.reply_address, self.returnsender, self.msg]
        

class TLSresponder(object):
    """This Class checks if a given mail should be responded to"""
    # check noreply and system addresses
    noreplies = [
        "mailer-daemon",
        "noreply@",
        "no_reply@",
        "no-reply@",
        "do-not-reply@",
        "bounce@"
        "www@",
        "www-data@",
        "wwwrun@",
        "nobody@",
        "apache@",
        "root@",
        "nagios@",
        "httpd@",
        "hostmaster@",
        "postmaster@",
        "svn@",
            ]
    # check disallowed header fields
    headers = [
        'List-Id',
        'List-Unsubscribe',
        'List-Help',
        'List-Info',
        'RT-Originator',
        'X-List',
        'X-List-ID',
        'X-MDMailing-List',
        'X-Mailing-List',
        'X-Mailer-ListID',
        'X-MailingID',
        'X-Mailing-Id',
        'X-Autoresponder',
        'X-Autorespond',
        'X-Bugzilla-Product',
        'X-Bugzilla-Type',
        'X-Email-Type-Id', # Paypal
        'X-Google-Address-Confirmation', # Google
        'X-Roundup-Version',
        'X-Trac-Version',
        'X-Whups-Generated',
        'X-Cron-Env',
        ]

    def __init__(self, incommingmail, mailer=MailSender):
        #read an parse mail header
        self.mail = open(incommingmail, "r")
        self.mailer = mailer
        parser    = HeaderParser()
        self.orig_msg  = parser.parsestr(self.mail.read())
        # read subject
        self.orig_subject = self.orig_msg.get('Subject')
        # read received, ignore all but last
        self.orig_received = self.orig_msg.get_all('Received')[0]
        # read sender
        self.returnsender = self.orig_msg['Return-Path'] or self.orig_msg['From']
        #replay adress
        self.reply_address = "test@testmail.test"


    def send_mail(self):
        try:
            os.mkdir(path)
        except:
            pass
        try:
            self.__abort_reason()
            msg = self.create_message()
            #self.create_mail(msg, path)
            mailer = self.mailer(self.reply_address, self.returnsender, msg.as_string())
            received = mailer.deliver()
            
            return received
            #print "TLS_Response send"
        except AbortReply("Some Reason"), e:
            raise


    def __abort(self, reason):
        reason = ("dropped, %s" % reason)
        raise AbortReply(reason)
        # must exit with zero
        # otherwise the MTA retries the delivery
        #sys.exit(0)

    # aborts if the given header matches the given value
    def __abort_if_header(self, name, disallowed):
        value = self.orig_msg.get(name)
        if value != None and value.lower() in disallowed:
            try:  
                abort("disallowed header: %s" % name);
            except AbortReply("some Reason"), e:
                raise DisallowedHeaderException(e.reason)

    # aborts if the given header exists and does NOT match the given value
    def __abort_if_header_not(self, name, disallowed):
        value = self.orig_msg.get(name)
        if value != None and value.lower() not in disallowed:
            try:  
                self.__abort("disallowed header: %s" % name);
            except AbortReply("some Reason"), e:
                raise DisallowedHeaderException(e.reason)


    def __abort_reason(self):
        try:
            reason = None
            if not self.orig_subject:
                self.__abort("subject missing");

        
            # check if locally deliveres
            if "localhost" in self.orig_received:
                self.__abort("locally delivered")

            #check if tls encrypted
            if self.orig_received.find("TLS")>-1:
                self.__abort("is send with tls")

            
            
            self.__abort_if_header_not('Auto-Submitted', 'no')
            self.__abort_if_header('X-Autogenerated', 'reply')
            self.__abort_if_header('X-Auto-Response-Suppress', 'all')
            self.__abort_if_header('X-Mailer', 'mediawiki mailer')
            self.__abort_if_header('X-Spam-Flag', 'yes')
            self.__abort_if_header('Precedence', ['list', 'bulk', 'junk'])
            self.__abort_if_header('Content-Description', 'delivery report')


            for name in TLSresponder.headers:
                if self.orig_msg.get(name) != None:
                    self.__abort("header present: %s" % name)



            sender_lower = self.returnsender.lower()
            for noreply in TLSresponder.noreplies:
                if noreply in sender_lower:
                    self.__abort("disallowed address")
        except AbortReply, e:
            raise
        except DisallowedHeaderException, e:
            raise
        else:
            pass

    # TODO


    #create mail
    def create_message(self):

        msg = Message()
        msg.set_payload("You send an unencrypted mail please consider TLS-encryption for your MailServer")
        msg["Subject"] = "SPAMSPAMSPAM" 
        msg["From"] = self.reply_address
        msg["To"] = self.returnsender
        return msg

    def create_mail(self, msg,path):
        email = open("%s/tls_respons.eml" % path,"w")
        email.write(msg.as_string())
        email.close()
      
class AbortReply(Exception):
    """docstring for AbortError"""
    def __init__(self, reason):
        self.reason = reason
    def __str__(self):
        return "No Reply: %s" % self.reason

class DisallowedHeaderException(AbortReply):
    pass


# TODO
# Wenn nicht DRY=1, dann Mail von STDIN parsen und Ergebnis auf STDOUT ausgeben
# Wenn Test-Framework geladen, nichts tun
# Ansonsten Mail von STDIN parsen und bei Bedarf Mail per localhost versenden
